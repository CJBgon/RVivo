#' Consistent colouring
#'
#' This function returns a vector with colours assigned to each treatment type
#' for consistent colours over the different plots.
#'
#'
#' @param vars A vector of different experimental conditions.
#' @param colourtype One of the RColorBrewer sets. "BW" can be specified if
#' you desire black and white images. this supports up to four vars.
#' Default = "Dark2.
#' @return A named vector with hex type colour codes per levels of "vars".
#' @import RColorBrewer
#' @export
colourpick<-function(vars, colourtype = "Dark2") {

  fac <- factor(vars)
  le <- length(levels(fac))
  if (colourtype == "BW") {
    colsop<- c("#f0f0f0", "#1e1e1e", "#bdbdbd", "#636363")
    cols <- colsop[1:le]
  } else {
    cols <- RColorBrewer::brewer.pal(le, colourtype)
  }
  names(cols) <-levels(fac)
  return(cols)
}


#' ggplot data prep
#'
#' This function creates a unique ID from the cage and mouse id. "Cage: A1 and
#' Mouse ID : L1 will create ID A1L1. it will subsequently melt the data to a
#' long format which can be used by ggplot2.
#'
#'
#' @param data a dataframe with 3 columns of identifiers followed by columns of
#' tumour growth values.
#' @param date indicate if the column names of each tumour growth values
#' are since onset experiment (1-...) or dates (01-01-2020). default = FALSE.
#' @return A named vector with hex type colour codes per levels of "vars".
#' @import data.table
#' @export
plotdat <- function(data, date=FALSE) {
  unID <- mapply(paste,
                 data$Cage,
                 data$`Mouse ID`,
                 USE.NAMES = F)
  unID <- sub(unID, pattern = " ", replacement = "")
  undata <- cbind(unID, data)
  meltgrowth <- data.table::melt(undata, id.vars = c(1:4))
  meltgrowth_use <- meltgrowth[!is.na(meltgrowth$value)]
  meltgrowth_use$value <- as.numeric(meltgrowth_use$value)

# stitch together each string along the columns
  if (date == T) {
  meltgrowth_use$variable <- as.Date(meltgrowth_use$variable,
                                     tryFormats = c("%d/%m/%Y",
                                                    "%Y-%m-%d",
                                                    "%Y/%m/%d"))
}
  return(meltgrowth_use)
}


#' plot all
#'
#' This function creates a ggplot. It displays the growth of all treatment
#' conditions over time in one graph. It does this by plotting individual
#' measurements and the mean of each treatment as a line with error bars.
#' Colours are assigned by Treatment name as the colourpick function generates.
#'
#'
#' @param data a long format of the tumour growth data as generated by plotdat.
#' @param type Should the plots be formatted in percentage growth or
#' regular values? options: "reg", "per".
#' Default = "reg"
#' @param colours A named vector with hex colours for each treatment variable
#' as generated by colourpick.
#' @param axis "linear" or "log", passes on axis infomation for the plots.
#' Default = "linear"
#' @return A ggplot showing growth of all treatment groups.
#' @import ggplot2
#' @export
vivoplot_overall <- function(data,
                             type = 'reg',
                             colours = colour,
                             axis = "linear") {
  if (axis == "log") {
    data$value[data$value == 0] <- 1
  }
  plot <- ggplot2::ggplot(data = data,
                          aes(x = as.numeric(variable),
                              y = value, group = Treatment)) +
    scale_fill_manual(values=colours)+
    scale_colour_manual(name = "Treatment", values = colours)+
    geom_smooth(aes(colour = Treatment, fill = Treatment),
                alpha = 0.3,
                span = 0.5)
   #  geom_point(aes(colour = Treatment, fill = Treatment),
   #              shape=21,
   #              size = 2,
   #              alpha = 0.3)
   # # facet_grid(~Treatment)

  if (axis == "log") {
    plot <- plot + scale_y_log10()
  }
  switch(type,
         per = {plot <- plot +
           labs(x = "Days", y ="Percentage growth")
         },
         reg = {plot <- plot +
           labs(x = "Days", y ="Tumour size (mm3)")
         },
         no = {plot <- plot +
           labs(x = "", y ="")
         })

  plot <- plot +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


  return(plot)
}


#' plot growth
#'
#' This function creates a ggplot that displays growth of each treatment in a
#' seperate graph. It plots a line displaying the growth over time for each
#' individual animal.
#' Colours are assigned by Treatment name as the colourpick function generates.
#'
#'
#' @param data a long format of the tumour growth data as generated by plotdat.
#' @param type Should the plots be formatted in percentage growth or
#' regular values? options: "reg", "per".
#' Default = "reg"
#' @param colours A named vector with hex colours for each treatment variable
#' as generated by colourpick.
#' @param line TRUE/FALSE If TRUE a line for each animal will be plotted,
#' otherwise dots will indicate each data point per animal. default = TRUE.
#' @param axis "linear" or "log", passes on axis infomation for the plots.
#' Default = "linear"
#' @return A ggplot of tumour growth per treatment group.
#' @import ggplot2
#' @export
vivoplot_treatment <- function(data,
                               type = 'reg',
                               colours = colour,
                               line = T,
                               axis = "linear") {
  if (axis == "log") {
    data$value[data$value == 0] <- 1
  }
  treatplot <- ggplot2::ggplot(data = data,
                               aes(x = variable,
                                   y = value,
                                   color = Treatment))

  if (line == F) {
    treatplot <- treatplot +
      geom_point(aes(group = Treatment), stat = 'identity')
  } else {
  treatplot <- treatplot +
    geom_line(aes(x = as.numeric(variable), y = value,
              group = unID))
  }

  if (axis == "log") {
    treatplot <- treatplot + scale_y_log10()
  }
  switch(type,
         per = {treatplot <- treatplot +
           labs(x = "Days", y ="Percentage growth")
         },
         reg = {treatplot <- treatplot +
           labs(x = "Days", y ="Tumour size (mm3)")
         },
         no = {treatplot <- treatplot +
           labs(x = "", y ="")
         })

  treatplot <- treatplot +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    facet_wrap(~Treatment) +
    scale_fill_manual(values = colours) +
    scale_colour_manual(name = "Treatment", values = colours)


  return(treatplot)
}


#' Plot survival data
#'
#' This function plots the data generated by survdata using survminer, a
#' ggplot extension.
#'
#' @param survivaldat A table with treatment, survival time and binary survival
#' indicator (1 = death, 0 = alive). as generated by survdata.
#' @param colours A named vector with hex colours for each treatment variable
#' as generated by colourpick.
#' @return a ggplot object.
#' @import ggplot2
#' @import survival
#' @import survminer
#' @export
survdataplot <- function(survivaldat = survframe, colours = colour) {
  micesurv <- survival::survfit(
    Surv(survtime, binarysurvi) ~ Treatment,
    data = survivaldat)
  survmineplot <- survminer::ggsurvplot(data = survivaldat,
                                        fit = micesurv,
                                        color = "Treatment",
                                        palette = colours)
  return (survmineplot)
}


#################################################################################
# development
# micemat <- tumcalc(volumes = "~/Documents/car/vol_mice_sheet.csv" )
# frame <- data.table::fread(file= "~/Documents/car/vol_mice_sheet.csv",
#                            select = c(1:3))
# first <- startpick(data = micemat, weight = 90)
# col <- colnames(micemat)
# intervalmatrix <- growthinterval(volumematrix = micemat, datecolumn = col)
# int <- exptime(volumematrix = micemat,datecolumn = col)
# colour <- colourpick(vars = frame$Treatment, colourtype = "Dark2")
# filledmat <- filldate(data = micemat, intervaltime = int)
# matmat <- plotmatrix(filledmatrix = filledmat, startdate = first, intervaltime = int)
# int_dat <- cbind(frame, matmat)
# plot_int_dat<- plotdat(int_dat, date = F)

# vivoplot_treatment(data = plot_int_dat, line = T, colours = colour)
# vivoplot_overall(data = plot_int_dat,error =F ,dots = T, colours = colour)
